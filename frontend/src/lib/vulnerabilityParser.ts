interface Vulnerability {
  name: string;
  cause: string;
  type: "low" | "medium" | "high" | "critical";
}

interface SeverityBreakdown {
  severity: string;
  count: number;
  weight: number;
}

interface VulnerabilityReportData {
  riskLevel: string;
  totalVulnerabilities: number;
  riskScore: number;
  maxScore: number;
  severityBreakdown: SeverityBreakdown[];
  vulnerabilities: Vulnerability[];
  mermaidChart?: string;
}

export function parseVulnerabilityReport(
  reportText: string,
): VulnerabilityReportData | null {
  try {
    // Extract risk level
    const riskLevelMatch = reportText.match(/Risk Level:\s*([^\n]+)/i);
    const riskLevel = riskLevelMatch?.[1]?.trim().toUpperCase() || "UNKNOWN";

    // Extract total vulnerabilities
    const totalMatch = reportText.match(/Total Vulnerabilities:\s*(\d+)/i);
    const totalVulnerabilities = totalMatch?.[1] ? parseInt(totalMatch[1]) : 0;

    // Extract risk score
    const scoreMatch = reportText.match(/Risk Score:\s*(\d+)\/(\d+)/i);
    const riskScore = scoreMatch?.[1] ? parseInt(scoreMatch[1]) : 0;
    const maxScore = scoreMatch?.[2] ? parseInt(scoreMatch[2]) : 100;

    // Extract severity breakdown from table
    const severityBreakdown: SeverityBreakdown[] = [];
    const severityTableMatch = reportText.match(
      /\| Severity \| Count \| Weight \|[\s\S]*?\|----------\|-------\|--------\|([\s\S]*?)\|/,
    );
    if (severityTableMatch?.[1]) {
      const rows = severityTableMatch[1]
        .split("|")
        .filter((row) => row.trim() && !row.includes("---"));
      for (let i = 0; i < rows.length; i += 3) {
        const severity = rows[i]?.trim();
        const count = rows[i + 1]?.trim();
        const weight = rows[i + 2]?.trim();
        if (severity && count && weight) {
          severityBreakdown.push({
            severity,
            count: parseInt(count) || 0,
            weight: parseInt(weight) || 0,
          });
        }
      }
    }

    // Extract vulnerabilities from details table
    const vulnerabilities: Vulnerability[] = [];
    const vulnTableMatch = reportText.match(
      /\| Name \| Cause \| Severity \|[\s\S]*?\|------\|-------\|----------\|([\s\S]*?)\|/,
    );
    if (vulnTableMatch?.[1]) {
      const rows = vulnTableMatch[1]
        .split("|")
        .filter((row) => row.trim() && !row.includes("---"));
      for (let i = 0; i < rows.length; i += 3) {
        const name = rows[i]?.trim();
        const cause = rows[i + 1]?.trim();
        const severity = rows[i + 2]?.trim()?.toLowerCase();
        if (name && cause && severity) {
          vulnerabilities.push({
            name,
            cause,
            type: severity as "low" | "medium" | "high" | "critical",
          });
        }
      }
    }

    // Extract mermaid chart
    const mermaidMatch = reportText.match(/```mermaid([\s\S]*?)```/);
    const mermaidChart = mermaidMatch?.[1]?.trim();

    return {
      riskLevel,
      totalVulnerabilities,
      riskScore,
      maxScore,
      severityBreakdown,
      vulnerabilities,
      mermaidChart,
    };
  } catch (error) {
    console.error("Error parsing vulnerability report:", error);
    return null;
  }
}

export function extractReportFromAuditData(
  auditData: string | string[],
): VulnerabilityReportData | null {
  const auditText = Array.isArray(auditData) ? auditData.join("\n") : auditData;

  console.log("Extracting report from audit data:", auditText);

  // Look for the JSON data in the raw data section first (most reliable)
  const jsonMatch = auditText.match(/"vulnerabilities":\s*\[[\s\S]*?\]/);
  if (jsonMatch) {
    try {
      const jsonData = JSON.parse(`{${jsonMatch[0]}}`);
      console.log("Found JSON data:", jsonData);

      // Extract basic info from the text
      const totalMatch = auditText.match(
        /(?:\*\*)?Total Vulnerabilities:(?:\*\*)?\s*(\d+)/i,
      );
      const scoreMatch = auditText.match(
        /(?:\*\*)?Risk Score:(?:\*\*)?\s*(\d+)\/(\d+)/i,
      );

      return {
        riskLevel: jsonData.vulnerabilities.length > 0 ? "HIGH" : "LOW",
        totalVulnerabilities:
          totalMatch && totalMatch[1]
            ? parseInt(totalMatch[1])
            : jsonData.vulnerabilities.length,
        riskScore: scoreMatch && scoreMatch[1] ? parseInt(scoreMatch[1]) : 0,
        maxScore: scoreMatch && scoreMatch[2] ? parseInt(scoreMatch[2]) : 100,
        severityBreakdown: [], // Will be calculated from vulnerabilities
        vulnerabilities: jsonData.vulnerabilities.map((v: any) => ({
          name: v.name,
          cause: v.cause,
          type: v.type.toLowerCase() as "low" | "medium" | "high" | "critical",
        })),
        mermaidChart: undefined,
      };
    } catch (e) {
      console.error("Failed to parse JSON data:", e);
    }
  }

  // Try to find the vulnerability report section
  const reportMatch = auditText.match(
    /# Vulnerability Assessment Report[\s\S]*?(?=```json|$)/,
  );
  if (reportMatch) {
    console.log("Found report section:", reportMatch[0]);
    return parseVulnerabilityReport(reportMatch[0]);
  }

  // If no specific section found, try to parse the entire text as a report
  console.log(
    "No specific report section found, trying to parse entire audit text",
  );
  return parseVulnerabilityReport(auditText);
}
